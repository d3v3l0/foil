<html>
<head>
	<link rel="stylesheet" type="text/css" media="screen" href="foil.css">
</head>
<body>
<h2>Foil - a Foreign Object Interface for Lisp</h2>
	<h5>Copyright (c) Rich Hickey and Eric Thorsen. All rights reserved.</h5>

	<p>
	The use and distribution terms for this software are covered by the <a href="http://opensource.org/licenses/cpl.php">Common 
	Public License 1.0</a>, which can be found in the file CPL.TXT at the root of 
	this distribution. By using this software in any fashion, you are agreeing to be 
	bound by the terms of this license. You must not remove this notice, or any 
	other, from this software.
	</p>

<h2>Description and Rationale</h2>

Foil consists of a protocol and a set of libraries that facilitate 
access to popular object runtimes, such as the JVM and the CLI/CLR, and 
their libraries, from Lisp.  A protocol is defined which abstracts out the 
common features provided by Java-like environments - object construction, 
method, field, and property access, object lifetime management etc.  The 
protocol defines a set of features as well as an s-expression based stream 
format for communication.  Runtime server applications are provided that 
utilize Java and C# libraries to implement the object runtime side of the 
protocol for Java and the CLI.  Source for the applications is provided so 
that custom hosts can be built.  A library for Common Lisp is provided 
that implements the consumer side of the protocol, and offers seamless 
access to the foreign objects in a Lisp-like manner.  

The design of Foil owes much to <a href="http://jfli.sourceforge.net/">jfli</a>, an in-process solution to the same 
problem for Java, and it remains extremely similar in its Lisp interface.  
Several factors motivated the significant difference in the Foil design -
its use of an out-of-process instance of the foreign runtime: 

<ul>
<li>jfli did not see wide porting, due to its use of LispWorks' sophisticated FLI to access JNI, 
    and the lack of corresponding facilities in some other Lisps</li>
<li>I found that I needed to access already-running instances of the JVM, 
    for instance servlet containers, as done in <a href="http://lisplets.sourceforge.net/">Lisplets</a>, and felt
    I could accomplish similar things with less effort with Foil + marshallers</li>
<li>I wanted to access the CLR/CLI in a similar fashion to Java</li>
<li>It allows for more flexibility in dealing with threading issues</li>
</ul>

The major tradeoff in stream-based access to out-of-proc runtimes is a 
significant drop in per-call performance.  However, even with jfli, which 
was very fast, the overhead of reflection per call could be high in 
certain scenarios, since the APIs of these platforms tend to be very 
'chatty'.  Foil includes a marshalling system that allows for efficient 
transfer of large and composite objects with minimal call overhead, in a 
manner that doesn't pollute the Lisp code on the consumer side.  

<h4>Foil provides all the facilities of jfli and more - </h4>

<h5>Some of the additions are:</h5>

<ul> 
	<li>(Hopefully) Much improved portability (n.b. it has not been ported, but is mostly standard CL)
	<li>Access to the CLR with the same API</li> 
	<li>Support for CLR and JavaBean properties</li>
	<li>Simultaneous access to multiple runtimes</li>
	<li>Simultaneous access to the CLR and Java</li>
	<li>A marshalling system which can, in a single call, pull across the types, hashcodes, and/or values of 
reference objects to an arbitrary depth, with user customizable value marshallers.</li> 
	<li>All references to the same remote object are <code>eq</code> on the Lisp side</li> 
	<li><code>ensure-typed-ref</code>, which makes a remote reference 
its most fully derived type in Lisp, works in place, using <code>change-class</code></li> 
	<li>vector argument boxing, so lightweight vectors-as-arguments can be created in-place 
		without the overhead of multiple calls to create and initialize the vector</li>
	<li>keyword-style init of properties in constructor calls is supported by the ctor functions, and can be leveraged 
		in apply and mapping scenarios (this feature was limited in jfli to the <code>new</code> macro)</li>
</ul>


<h5>Features of jfli that are retained/enhanced:</h5>

	<ul>

		<li>
			Automatic function generation for constructors, fields, methods, and properties either by 
			named class, or entire package (sub)trees given a jar file or assembly name.
		</li>

		<li>
			Java/CLI -> Lisp package and name mapping with an eye towards lack of surprise, lack 
			of conflict, and useful editor completion.
		</li>

		<li>
			setf-able setter generation for fields and properties		</li>

		<li>
			Java/CLI vector creation and aref-like access to Java/CLI vectors.
		</li>

		<li>
			Constructors that allow for keyword-style property initialization.
		</li>

		<li>
			Typed references to Java/CLI objects with an inheritance hierarchy on the Lisp side 
			mirroring that on the Java/CLI side - allowing for Lisp methods specialized on Java/CLI 
			class and interface types.
		</li>

		<li>
			Implementation of arbitrary Java/CLI interfaces in Lisp, and callbacks from Java/CLI to 
			Lisp via those interfaces. </li>

		<li>
			Automatic lifetime maintenance of Lisp-referenced Java/CLI objects, boxing/unboxing 
			of primitive args/returns, string conversions, Java/CLI exception handling, overload 
			resolution etc.
		</li>
	</ul>


	<a name="download"></a> <h3>Download and Communication</h3>

	<p>
	<a href="http://sourceforge.net/projects/foil/">Foil is hosted on SourceForge</a> 
    <a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=125543&amp;type=1"
				width="88" height="31" border="0" alt="SourceForge.net Logo" /></a>
    </p>
    <p>We are going to try using SourceForge facilities for all communication regarding Foil, 
    so please use the project tracker and forums there.
	</p>


	<a name="api"></a> <h2>Lisp API Reference</h2>

    <a name="fvms"></a> <h3>Foreign VMs</h3>
    <p>
    Foil is built upon the notion of interactions with one or more foreign VMs, 
    instances of the JVM or CLR, running the Foil libraries, in another process on 
    the same or another machine. The connection to a specific VM is via one or more 
    bidirectional streams. Note that the instantiation of the foreign VM and the 
    establishment of the streams is outside the scope of this Lisp API. It is 
    presumed you might try one of the supplied runtime servers, creating stream 
    connections via sockets or pipes with the API provided by your Lisp 
    implementation. Many scenarios are possible, including embedding the Foil 
    support libraries into your existing Java or C# application, multiple streams to different threads in the same VM, etc.
    </p>
    <p>
    A foreign VM is represented by an instance of the <code>foreign-vm</code> class. Each instance has a primary default stream 
    over which communication will occur. The special variable <code>*fvm*</code> represents the default VM to which any unqualified
    Foil calls will be directed.
    </p>
	<ul>
    </ul>

        		
    <a name="fvms"></a> <h3>Foreign References</h3>


	<ul>
    </ul>

                <a name="wrappergen"></a> <h3>Wrapper Generation</h3>

	<ul>
		<li>
			<strong>Macro</strong> <code>(def-foil-class full-class-name) -> unspecified</code>
			<p>
			Given the package-qualified, case-correct name of a Java/CLI class as a string, will 
			generate wrapper functions for its public constructors, fields, properties and methods.
			</p>
			<p>
			The core API for generating interfaces to Java/CLI is the <code>def-foil-class</code> macro. This 
			macro will, at expansion time, use Java/CLI reflection to find all of the public 
			constructors, fields, properties and methods of the given class and generate functions to 
			access them.
			</p>
			<h4>The Generated API</h4> 
			When you e.g. <code>(def-foil-class "java.lang.ClassName")</code> 
			you get several symbols/functions:
			<ul>
				<li>
					A package named <code>|java.lang|</code> (note case)<br>
					from which the following are exported:
				</li>
				<li>
					A class-symbol: <code>classname.</code> (note the dot is part of the name)<br>
					which can usually be used where a typename is required. It also serves as the 
					name of the Lisp typed reference class.
				</li>
				<li>
					Every non-interface class with a public constructor will get;
					<ul>
						<li>
							A constructor, <code>(classname.new &rest args) -> fref</code>, which 
							returns a foreign-reference (fref) to the newly created object. Note that the constructor function,
							and therefore everything built upon it, can take the actual arguments to the Java/CLI ctor, followed by
							zero or more property initializers, which take the form:<br>
							:keywordized-propertyname value<br>
							e.g. <code>(window.new parent :width 200 :height 200)</code> <br>
							thus supporting the creation and some setup of a new object in a single call

						</li>
						<li>
							A method defined on <a href=#makenew><code>make-new</code></a>, ultimately 
							calling <code>classname.new</code>, specialized on (the value of) the class-symbol
						</li>
					</ul>
					Note that if the constructor is overloaded, there is just one function generated, 
					which handles overload resolution. The function documentation string describes 
					the constructor signature(s) from the Java/CLI perspective. The same argument 
					conversions are performed as are for fields (see below).
				</li>
				<li>
					All public fields will get a getter function:<br>
					<code>(classname.fieldname [instance]) -> field value</code><br>
					and a setter:<br>
					<code>(setf classname.fieldname [instance])</code><br>
					Instance field wrappers take a first arg which is the instance. Static fields 
					get a symbol-macro <code>*classname.fieldname*</code>
					<p>
					If the type of the field is primitive, the field value will be converted to a 
					native Lisp value. If it is a Java/CLI String, it will be converted to a Lisp string. 
					Otherwise, a foreign reference to the Java/CLI object is returned. Similarly, when 
					setting, Lisp values will be accepted for primitives, Lisp strings for Strings, 
					or foreign references for reference types.
					</p>
				</li>
				<li>
					All public properties (explicit properties in the case of the CLI, 
					implied properties in the case of Java as specified by the JavaBeans protocol) 
					will get a getter function if the property supports get:<br>
					<code>(classname.propertyname [instance] [args]) -> property value</code><br>
					and a setter if the property supports set:<br>
					<code>(setf classname.propertyname [instance] [args])</code><br>
					Instance property wrappers take a first arg which is the instance. Static properties 
					get a symbol-macro <code>*classname.propertyname*</code>
				</li>
				<li>
					Every public method will get a wrapper function:<br>
					<code>(classname.methodname &rest args) -> return-value</code><br>
					As with constructors, if a method is overloaded a single wrapper is created that 
					handles overload resolution. 
					<p>
					The same argument and return value conversions are performed as are for fields. 
					The function documentation string describes the method signature(s) from the 
					Java/CLI perspective.
					</p>

				</li>
				<li>
					A Lisp class with the class-symbol as its name. It will have as its superclasses 
					other Lisp classes corresponding to the Java/CLI superclass/superinterfaces, some of 
					which may be forward-referenced-classes, and will be ultimately derived from <code>fref</code>.  
                    An instance of this class will be 
					returned by <code>ensure-typed-ref</code>, at which point the entire hierarchy will 
					consist of finalized standard-classes.
				</li>
				<li>
					Note that, due to the need to reference other Java/CLI types during the definition 
					of a class wrapper, symbols, classes, and packages relating to those other types 
					may also be created. In all cases they will be created with names and 
					packages as described above.
				</li>
			</ul>

		</li>
				<li>
            			<strong>Function</strong> <code>(get-jar-classnames jar-file-name &rest packages) 
			-> list-of-strings</code>
			<p>
			Returns a list of class name strings. Packages should be strings of the form "java/lang 
			 " for recursive lookup and "java/util/" (note trailing slash) for non-recursive. This function
                    is in foil-java.lisp and is only for Java.
			</p>
				</li>
				<li>
            			<strong>Function</strong> <code>(get-assembly-classnames assembly-file-name &rest packages) 
			-> list-of-strings</code>
			<p>
			Returns a list of class name strings.  Assemblies should be of the form "System/IO"
  for recursive lookup and "System/IO/" for non-recursive (note trailing slash). This function
                    is in foil-cli.lisp and is only for the CLI.
			</p>
				</li>
		<li>
			<strong>Function</strong> <code>(dump-wrapper-defs-to-file filename classnames)  -> 
			unspecified</code>
			<p>
			Given a list of classnames (say from <code>get-jar-classnames</code> or <code>get-assembly-classnames</code>), writes 
			the consolidated expansions of calls to <code>def-foil-class</code> to a file:
			</p>
			<pre>
(dump-wrapper-defs-to-file "/lisp/java-lang.lisp"
  (get-jar-classnames "/j2sdk1.4.2_01/jre/lib/rt.jar " "java/lang/"))
(compile-file "/lisp/java-lang")
(load "/lisp/java-lang")
(use-package "java.lang")
;Wrappers for all of java.lang are now available
</pre>
            This is the recommended way to access entire library packages. In particular, it has the advantage that the dumped
            code does not require a foreign runtime to either compile or load.
		</li>
</ul>

    <a name="objectservices"></a> <h3>Object Services</h3> These functions provide 
    access to basic facilities provided by all runtimes (usually through syntax or 
    the Object class), but should be used instead, as they are portable and can be 
    more efficient, caching and resolving some things locally on the Lisp side.
    <ul>
        <li>
            <strong>Function</strong> <code>(equals fref1 fref2) -> boolean</code>
            <p>
            Portable Object.equals/Equals
            </p>
        </li>
        <li>
            <strong>Function</strong> <code>(instance-of fref type) -> boolean</code>
            <p>
            Portable instanceof/is
            </p>
        </li>

        <li>
            <strong>Function</strong> <code>(to-string fref) -> string</code>
            <p>
            Portable Object.toString/ToString
            </p>
        </li>

        <li>
            <strong>Function</strong> <code>(hash fref &key rehash) -> int</code>
            <p>
            Portable Object.hasCode/GetHashCode. Note: will cache the value on the fref. If 
            already cached, will return that, unless :rehash is t.
            </p>
        </li>

        <li>
            <strong>Function</strong> <code>(get-type fref) -> Class or Type fref</code>
            <p>
            Portable Object.getClass/GetType. Note: will cache the value on the fref. Note also that obtaining the exact type of
            the object is completely independent of the coercion of the fref to its corresponding Lisp type 
            (see <code>ensure-typed-ref</code>)
            </p>
        </li>

    </ul>

<h2>Protocol</h2>

The foil protocol describes the on-stream interface between a Lisp 
instance and a runtime instance, and should not be confused with the foil 
library which provides the interface to the protocol for Common Lisp.  A user
        of Foil will not need to know the protocol, but if you intend to add support
        for another runtime environment (Python anyone?) or host language (Scheme anyone?),
        hopefully this section will help. Note that the protocol docs are not formal, and
        mostly consists of notes to myself and Eric. This will be improved when I get time. For the moment,
        should there be any omissions or inaccuracies here, the Lisp and Java implementations should be 
         considered canonic.

<h3>Connection Services</h3> 

Foil is a stream-based protocol.  However, no 
protocol is provided for the establishment of the streams - that is an 
implementation detail of the runtime and Lisp libraries.  It is suggested 
that any foil runtime implementation provide at least a stand-alone 
executable server that implements the protocol over its standard IO ports, as well  
        as being able to run over a TCP/IP socket.
Many other scenarios are possible, including multi-socket servers, pre-existing Lisp and runtime 
instances discovering each other etc.  The remainder of the protocol 
description presumes a bi-directional stream has been established.  

Sendable messages:
<ul>

<li>	(:cref</li>
	<li>(:call</li>
		<li>(:free</li>
		<li>(:new</li>
	<li>(:marshall</li>
	<li>(:hash</li>
	<li>(:equals</li>
	<li>(:type-of</li>
	<li>(:is-a</li>
	<li>(:str</li>
	<li>(:tref</li>
	<li>(:bases</li>
	<li>(:members</li>
	<li>(:vector</li>
	<li>(:vget</li>
	<li>(:vset</li>
	<li>(:vlen</li>
	<li>(:proxy</li>
	<li>(:iget</li>
	<li>(:iset</li>


</ul>
<p>Returnable messages:
<ul>

	<li>(:ret</li>
	<li>(:err</li>
	<li>(:proxy-call	;only async or from withing a :call</li>

</ul>

<h3>Invocation Services</h3>
	Obtaining callable references (crefs)
<p>	<code>(:cref member-type tref|"packageQualifiedTypeName" "memberName")</code>
<p>		Where member-type is an integer representing one of:
<ul>		 
			<li>method (0)</li>
			 <li>field (1)</li>
			 <li>property-get (3)</li>
			 <li>property-set (4)</li>
 </ul>

<p>		Note that both Java and the CLI support overloading, so a single member name might map to multiple overloads. 
		The resolution of the overloading must occur in the runtime server at the time of invocation, i.e. any of the overloads
		may be called through the same cref.

<p>		Returns -> A reference to a callable thing is returned in the standard return format (see below).
<p>		<code>(:ret #{:ref ...})</code>

<p> <h4> Creating new object instances</h4>
<p> 	<code>(:new tref marshall-flags marshall-value-depth-limit (args ...) property-inits ...)</code><br>
<p> where property-inits is a set of <code>:keyword-style-name value</code> pairs
<p><h4>Calling a callable</h4>
			<code>(:call cref marshall-flags marshall-value-depth-limit target args ...)</code><br>

<p>			Example:<p>
				<code>(:call #}101 1 0 2 #}17 "fred")</code>

<p>			Where cref is an cref that has been obtained via :cref, or, only in the case of calls to Lisp, 
			a symbol that names a function.

<br>			marshalling-flags is an integer representing a bitwise-or'ing of:
<ul>

<li>				marshall-id (1)</li>
				<li>marshall-type (2)</li>
				<li>marshall-hash (4)</li>

</ul>
			a marshall-value-depth-limit of 0 means no reference values are marshalled, a setting of 1 means 
			that reference values will be marshalled for the return value (if it is a reference), but not any nested references. 
			When > 1 nested reference types will marshall to that depth of nesting.
            <br> If marshalling-flags is 0, no references will be returned (only values) and if depth is also 0 then nil will be returned.

<br>	target is the object upon which to invoke the method/field/property - pass nil if static

<br>			args are zero or more args as per below.

<p>		<h4>Return Format</h4>
<br>			one of:
<ul>
<li>			<code>(:ret value)</code><br>
				All normal returns are packaged in a form as above, value is as per below. 
				If a function has a void return type, nil should be returned. </li>
			<li><code>(:proxy-call ...)</code><br>
				A nested callback, in the proxy-call format described below. The receiver should process the call, 
				send back its return, then re-read
				the stream for the return value of the original call.</li>
			<li><code>(:err "error description" "stack trace")</code><br>
				returned if an exception occurred while processing the request</li>

</ul>
		<h4>Argument and Return Values</h4>
			Primitives and Value Types<br>
			<ul>

				<li>"Strings are in double quotes"</li>
				<li>Numbers are unadorned decimal numbers with or without a decimal point,leading -, e etc</li>
				<li>nil is null</li>
				<li>nil is false</li>
				<li>t is true</li>
			</ul>

			<p><h4>Boxed Primitives</h4>
				Occasionally it may be necessary to provide a hint as to the intended type of a numeric argument in order to 
				force resolution to a particular overload.

				<p><code>#{:box typename value}</code><br>

                <p>Where typename is one of <code>:byte :int :long :short :float :double</code>
				<p>N.B. silent truncation may occur
				<p>Return values should never be boxed<br>

			<p><h4>vector literals</h4>
			A vector can be specified in-line as an argument
				<code>#{:vector "packageQualifiedTypeName"|tref|:int(etc) value ...}</code><br>

			<p><h4>References</h4>

				Reference types are returned with the following tagged syntax:<br>

				<code>#{:ref id rev :type a-ref :hash an-int :val marshalled-value}</code>
				<ul>


				<li>:ref, id, and rev must be supplied, all others are optional</li>

				<li>id - A unique integer reference that identifies the object. The object will be kept alive on the hosting side 
					until it is freed. Multiple references to the same object will always have the same id. 
					</li>

				<li>:type - A reference to the Type (CLI) or Class (Java) object that is the type of the object. Note that this may be the 
					first time this reference is seen (and thus it must be registered for lifetime maintenance)
					This will only be available if the marshall-type flag is set.</li>

				<li>:hash - An integer representing the hash value of the object. This will only be available if the marshall-hash flag is set.</li>

				<li>:val - A Lisp-readable representation of the value of the object. This will be obtained by using the marshaller 
					registered for the type of the object. This will only be available when marshall-value-depth-limit is > 0. 
					Note #{ and #} user-space read macros are used by the implementation of foil.</li>
	

				</ul>
				 Note that it is possible to return marshalled values of reference objects without maintaining the reference object 
				 on the hosting side (by setting the marshall-id flag to 0 and having marshall-value-depth-limit > 0

				 <p>A reference (obtained previously) is passed back to its host like this:

				 <p><code>#}123</code>

				 <p>The host will look up the object with that id and pass it along to the call.

		<br><h4>Exception Reporting</h4>
			All exceptions are reported via a return of the form:<p>
			<code>(:err "error description" "stack trace")</code><p>
				if an exception occurred while processing the request. Unless the exception originated in the reflection API, 
				it is preferred that the stack trace be of the inner (reflection-invoked) call.

<h3>Object support services</h3>
		<h4>Object references</h4>
		<h4>Object lifetime management</h4>
			<code>(:free refid refrev ...)</code> -> nil
			

<p>a list of id/rev pairs is passed.  Allows one or more refs to be GC-ed 
on the hosting side.  It is an error to refer to these refids again.<br> 

        <h4>Object marshalling</h4><p>
			It is anticipated that runtime servers will provide for user-installable marshallers, associated with types,
			that will render the value of an object of that type on a stream in a form readable by Lisp. By default at least
			the following marshallers should be provided:
				<ul>

				<li>Type|Class - must always marshall the string representing the packageQualifiedTypeName, ignoring marshalling-depth</li>
				<li>arrays - should marshall as simple vector literals: #(...)</li>
				<li>collections and other enumerable entities - should marshall as simple lists (...)</li>
				<li>default, if no other marshaller applies - should yield an assoc-list of keywordized-property-name/value pairs</li>

				</ul><p>
			In addition to marshalling returns during calls, the value of an object reference can be explicitly marshalled:
			<p><code>(:marshall ref marshall-flags marshall-value-depth-limit)</code> -> Lisp-readable-value

		<p>Hash values<br>
			<code>(:hash ref)</code> -> int<br>

		<p>Object equality<br>
			<code>(:equals ref ref)</code> -> t|nil, per Object.Equals<br>

		<p>ToString<br>
			<code>(:str ref)</code> -> "string value"<br>

 <p><h3>Reflection Services</h3>


	Note, when trefs are returned by these reflection calls, the :val field of the reference is always (default) marshalled, 
	i.e. set to the packageQualifiedTypeName as a string.

	<p><h4>Obtaining a reference to a Type/Class object</h4>
	<code>(:tref "packageQualifiedTypeName")</code> -> tref<br>

	<p><h4>Object type</h4>
		<code>(:type-of ref)</code> -> tref<br>


	<p><code>(:is-a ref tref)</code> -> t|nil<br>

	<p><code>(:bases tref|"packageQualifiedTypeName")</code><br>
<pre>
-> (:ret ("packageQualifiedTypeName" ...))    ;most-derived to least-derived
</pre>


	<p><code>(:members tref|"packageQualifiedTypeName")</code><br>

	<code>
<pre>
-> (:ret ( (:ctors doc-string ...)
        (:methods ((:name string)
                   (:static bool)
                   (:doc doc-string)) ...)
        (:fields ((:name string)
                  (:static bool)
                  (:doc doc-string)) ...)
        (:properties ((:name string)
                      (:static bool)
                      (:get-doc doc-string)
                      (:set-doc doc-string)) ...)))</pre></code>

<h4>Proxies</h4>
<pre>
<code>(:proxy marshall-flags marshall-value-depth-limit interface-trefs ...)</code><br>
-> (:ret proxy-ref)
</pre>
<p>
		Creates a proxy object that implements the given interface(s). When any of the object's methods are called,
		sends a :proxy-call message of the form:<p>
		<code>(:proxy-call method-symbol proxy-ref args ...)</code>
		<p>where the proxy-ref is the same one originally returned from the :proxy message, and the
		args are marshalled with the flags and depth requested in the :proxy message. method-symbol has the form<p>
		<code>|package.name|::classname.methodname</code><p>note this means that the Lisp names are not independent, hmmm...

<h3>Vectors</h3>
	Creating an vector:<br>
	<ul>

	<li>(:vector tref|"packageQualifiedTypeName" length value ...)
		Creates an vector of the specified type with the specified length
		Initial values are optional and may be fewer than the length.
		-> aref</li>
	<li>(:vget aref marshall-flags marshall-value-depth-limit index)
		-> value</li>
	<li>(:vset aref index value)
		-> nil</li>
	<li>(:vlen aref)
		-> int</li>
	</ul>

</body>
</html>
