<html>
<head>
	<link rel="stylesheet" type="text/css" media="screen" href="foil.css">
</head>
<body>
<h2>Foil - a Foreign Object Interface for Lisp</h2>
	<h5>Copyright (c) Rich Hickey and Eric Thorsen. All rights reserved.</h5>

	<p>
	The use and distribution terms for this software are covered by the <a href="http://opensource.org/licenses/cpl.php">Common 
	Public License 1.0</a>, which can be found in the file CPL.TXT at the root of 
	this distribution. By using this software in any fashion, you are agreeing to be 
	bound by the terms of this license. You must not remove this notice, or any 
	other, from this software.
	</p>

<h2>Description and Rationale</h2>

Foil consists of a protocol, and a set of libraries, that facilitate 
access to popular object runtimes, such as the JVM and the CLI/CLR, and 
their libraries, from Lisp.  A protocol is defined which abstracts out the 
common features provided by Java-like environments - object construction, 
method, field, and property access, object lifetime management etc.  The 
protocol defines a set of features as well as an s-expression based stream 
format for communication.  Runtime server applications are provided that 
utilize Java and C# libraries to implement the object runtime side of the 
protocol for Java and the CLI.  Source for the applications is provided so 
that custom hosts can be built.  A library for Common Lisp is provided 
that implements the consumer side of the protocol, and provides seamless 
access to the foreign objects in a Lisp-like manner.  

The design of Foil owes much to jfli, an in-process solution to the same 
problem for Java, and it remains extremely similar in the Lisp interface.  
Several factors motivated the significant difference in the Foil design -
its use of an out-of-process instance of the foreign runtime: 

<ul>
<li>jfli did not see wide porting, due to its use of LispWorks' sophisticated FLI to access JNI</li>
<li>I found that I needed to access already-running instances of the JVM, for instance servlet containers, as done in Lisplets</li>
<li>I wanted to access the CLR/CLI in a similar fashion</li>
</ul>

The major tradeoff in stream-based access to out-of-proc runtimes is a 
significant drop in per-call performance.  However, even with jfli, which 
was very fast, the overhead of reflection per call could be high in 
certain scenarios, since the APIs of these platforms tend to be very 
'chatty'.  Foil includes a marshalling system that allows for efficient 
transfer of large and composite objects with minimal call overhead, in a 
manner that doesn't pollute the Lisp code on the consumer side.  

Foil provides all the facilities of jfli and more. 

Some of the additions are:

<ul> 
	<li>(Hopefully) Much improved portability (n.b. it has not been ported, but is mostly standard CL)
	<li>Access to the CLR with the same API</li> 
	<li>Support for CLR and JavaBean properties</li>
	<li>Simultaneous access to multiple runtimes</li>
	<li>Simultaneous access to the CLR and Java</li>
	<li>A marshalling system, which can, in a single call, pull across the types, hashcodes, and/or values of 
reference objects to an arbitrary depth, with user customizable value marshallers.</li> 
	<li>All references to the same remote object are eq on the Lisp side</li> 
	<li><code>ensure-typed-ref</code>, which makes a remote reference 
its most fully derived type in Lisp, works in place, using <code>change-class</code></li> 
	<li>vector argument boxing, so lightweight vectors-as-arguments can be created in-place 
		without the overhead of multiple calls to create and initialize the vector</li>
	<li>keyword-style init of properties in constructor calls is supported by the ctor functions, and can be leveraged 
		in apply and mapping scenarios (this feature was previously limited to the new macro)</li>
</ul>


Features of jfli that are retained/enhanced:

	<ul>

		<li>
			Automatic function generation for constructors, fields, methods, and properties either by 
			named class, or entire package (sub)trees given a jar file or assembly name.
		</li>

		<li>
			Java/CLI -> Lisp package and name mapping with an eye towards lack of surprise, lack 
			of conflict, and useful editor completion.
		</li>

		<li>
			setf-able setter generation for fields and properties		</li>

		<li>
			Java/CLI vector creation and aref-like access to Java/CLI vectors.
		</li>

		<li>
			Constructors that allow for keyword-style property initialization.
		</li>

		<li>
			Typed references to Java/CLI objects with an inheritance hierarchy on the Lisp side 
			mirroring that on the Java/CLI side - allowing for Lisp methods specialized on Java/CLI 
			class and interface types.
		</li>

		<li>
			Implementation of arbitrary Java/CLI interfaces in Lisp, and callbacks from Java/CLI to 
			Lisp via those interfaces. </li>

		<li>
			Automatic lifetime maintenance of Lisp-referenced Java/CLI objects, boxing/unboxing 
			of primitive args/returns, string conversions, Java/CLI exception handling, overload 
			resolution etc.
		</li>
	</ul>


	<a name="download"></a> <h3>Download</h3>

	<p>
	Foil is hosted on <a href="http://sourceforge.net/projects/foil/">SourceForge</a>
	</p>


	<a name="api"></a> <h2>API Reference</h2>
		<a name="wrappergen"></a> <h3>Wrapper Generation</h3>

	<ul>
		<li>
			<strong>Macro</strong> <code>(def-foil-class full-class-name) -> unspecified</code>
			<p>
			Given the package-qualified, case-correct name of a Java/CLI class as a string, will 
			generate wrapper functions for its public constructors, fields, properties and methods.
			</p>
			<p>
			The core API for generating interfaces to Java/CLI is the <code>def-foil-class</code> macro. This 
			macro will, at expansion time, use Java/CLI reflection to find all of the public 
			constructors, fields, properties and methods of the given class and generate functions to 
			access them.
			</p>
			<h4>The Generated API</h4> 
			When you e.g. <code>(def-foil-class "java.lang.ClassName")</code> 
			you get several symbols/functions:
			<ul>
				<li>
					A package named <code>|java.lang|</code> (note case)<br>
					from which the following are exported:
				</li>
				<li>
					A class-symbol: <code>classname.</code> (note the dot is part of the name)<br>
					which can usually be used where a typename is required. It also serves as the 
					name of the Lisp typed reference class.
				</li>
				<li>
					Every non-interface class with a public constructor will get;
					<ul>
						<li>
							A constructor, <code>(classname.new &rest args) -> fref</code>, which 
							returns a foreign-reference (fref) to the newly created object. Note that the constructor function,
							and therefor everything built upon it, can take the actual arguments to the Java/CLI ctor, followed by
							zero or more porperty initializers, which take the form:<br>
							:keywordized-propertyname value<br>
							e.g. <code>(window.new parent :width 200 :height 200)</code> <br>
							thus supporting the creation and setup of a new object in a single call

						</li>
						<li>
							A method defined on <a href=#makenew><code>make-new</code></a>, ultimately 
							calling <code>classname.new</code>, specialized on (the value of) the class-symbol
						</li>
					</ul>
					Note that if the constructor is overloaded, there is just one function generated, 
					which handles overload resolution. The function documentation string describes 
					the constructor signature(s) from the Java/CLI perspective. The same argument 
					conversions are performed as are for fields (see below).
				</li>
				<li>
					All public fields will get a getter function:<br>
					<code>(classname.fieldname [instance]) -> field value</code><br>
					and a setter:<br>
					<code>(setf classname.fieldname [instance])</code><br>
					Instance field wrappers take a first arg which is the instance. Static fields 
					get a symbol-macro <code>*classname.fieldname*</code>
					<p>
					If the type of the field is primitive, the field value will be converted to a 
					native Lisp value. If it is a Java/CLI String, it will be converted to a Lisp string. 
					Otherwise, a foreign reference to the Java/CLI object is returned. Similarly, when 
					setting, Lisp values will be accepted for primitives, Lisp strings for Strings, 
					or foreign references for reference types.
					</p>
				</li>
				<li>
					All public properties (explicit properties in the case of the CLI, 
					implied properties in the case of Java as specified by the JavaBeans protocol) 
					will get a getter function if the property supports get:<br>
					<code>(classname.propertyname [instance] [args]) -> property value</code><br>
					and a setter if the property supports set:<br>
					<code>(setf classname.propertyname [instance] [args])</code><br>
					Instance property wrappers take a first arg which is the instance. Static properties 
					get a symbol-macro <code>*classname.propertyname*</code>
				</li>
				<li>
					Every public method will get a wrapper function:<br>
					<code>(classname.methodname &rest args) -> return-value</code><br>
					As with constructors, if a method is overloaded a single wrapper is created that 
					handles overload resolution. 
					<p>
					The same argument and return value conversions are performed as are for fields. 
					The function documentation string describes the method signature(s) from the 
					Java/CLI perspective.
					</p>

				</li>
				<li>
					A Lisp class with the class-symbol as its name. It will have as its superclasses 
					other Lisp classes corresponding to the Java/CLI superclass/superinterfaces, some of 
					which may be forward-referenced-classes.  An instance of this class will be 
					returned by <code>ensure-typed-ref</code>, at which point the entire hierarchy will 
					consist of finalized standard-classes.
				</li>
				<li>
					Note that, due to the need to reference other Java/CLI types during the definition 
					of a class wrapper, symbols, classes, and packages relating to those other types 
					may also be created. In all cases they will be created with names and 
					packages as described above.
				</li>
			</ul>
		</li>

<h2>Protocol</h2>

The foil protocol describes the on-stream interface between a Lisp 
instance and a runtime instance, and should not be confused with the foil 
library which provides the interface to the protocol for Common Lisp.  

<h3>Connection Services</h3> 

Foil is a stream-based protocol.  However, no 
protocol is provided for the establishment of the streams - that is an 
implementation detail of the runtime and Lisp libraries.  It is suggested 
that any foil runtime implementation provide at least a stand-alone 
executable server that implements the protocol over its standard IO ports.  
Many other scenarios are possible, including socket servers, pre-existing Lisp and runtime 
instances discovering each other etc.  The remainder of the protocol 
description presumes a bi-directional stream has been established.  

Sendable messages:
<ul>

<li>	(:cref</li>
	<li>(:call</li>
		<li>(:free</li>
		<li>(:new</li>
	<li>(:marshall</li>
	<li>(:hash</li>
	<li>(:equals</li>
	<li>(:type-of</li>
	<li>(:is-a</li>
	<li>(:str</li>
	<li>(:tref</li>
	<li>(:bases</li>
	<li>(:members</li>
	<li>(:vector</li>
	<li>(:vget</li>
	<li>(:vset</li>
	<li>(:vlen</li>
	<li>(:proxy</li>

</ul>
<p>Returnable messages:
<ul>

	<li>(:ret</li>
	<li>(:err</li>
	<li>(:proxy-call	;only async or from withing a :call</li>

</ul>

<h3>Invocation Services</h3>
	Obtaining callable references (crefs)
<p>	<code>(:cref member-type tref|"packageQualifiedTypeName" "memberName")</code>
<p>		Where member-type is an integer representing one of:
<ul>		 
			<li>method (0)</li>
			 <li>field (1)</li>
			 <li>property-get (3)</li>
			 <li>property-set (4)</li>
 </ul>

<p>		Note that both Java and the CLI support overloading, so a single member name might map to multiple overloads. 
		The resolution of the overloading must occur in the runtime server at the time of invocation, i.e. any of the overloads
		may be called through the same cref.

<p>		Returns -> A reference to a callable thing is returned in the standard return format (see below).
<p>		<code>(:ret #{:ref ...})</code>

<p> <h4> Creating new object instances</h4>
<p> 	<code>(:new tref marshall-flags marshall-value-depth-limit (args ...) property-inits ...)</code><br>
<p> where property-inits is a set of <code>:keyword-style-name value</code> pairs
<p><h4>Calling a callable</h4>
			<code>(:call cref marshall-flags marshall-value-depth-limit target args ...)</code><br>

<p>			Example:<p>
				<code>(:call #}101 1 0 2 #}17 "fred")</code>

<p>			Where cref is an cref that has been obtained via :cref, or, only in the case of calls to Lisp, 
			a symbol that names a function.

<br>			marshalling-flags is an integer representing a bitwise-or'ing of:
<ul>

<li>				marshall-id (1)</li>
				<li>marshall-type (2)</li>
				<li>marshall-hash (4)</li>

</ul>
			a marshall-value-depth-limit of 0 means no reference values are marshalled, a setting of 1 means 
			that reference values will be marshalled for the return value (if it is a reference), but not any nested references. 
			When > 1 nested reference types will marshall to that depth of nesting.

<br>	target is the object upon which to invoke the method/field/property - pass nil if static

<br>			args are zero or more args as per below.

<p>		<h4>Return Format</h4>
<br>			one of:
<ul>
<li>			<code>(:ret value)</code><br>
				All normal returns are packaged in a form as above, value is as per below. 
				If a function has a void return type, nil should be returned. </li>
			<li><code>(:proxy-call ...)</code><br>
				A nested callback, in the proxy-call format described below. The receiver should process the call, 
				send back its return, then re-read
				the stream for the return value of the original call.</li>
			<li><code>(:err "error description" "stack trace")</code><br>
				returned if an exception occurred while processing the request</li>

</ul>
		<h4>Argument and Return Values</h4>
			Primitives and Value Types<br>
			<ul>

				<li>"Strings are in double quotes"</li>
				<li>Numbers are unadorned decimal numbers with or without a decimal point,leading -, e etc</li>
				<li>nil is null</li>
				<li>nil is false</li>
				<li>t is true</li>
			</ul>

			<p><h4>Boxed Primitives</h4>
				Occasionally it may be necessary to provide a hint as to the intended type of a numeric argument in order to 
				force resolution to a particular overload.

				<p><code>#{:box typename value}</code><br>

                <p>Where typename is one of <code>:byte :int :long :short :float :double</code>
				<p>N.B. silent truncation may occur
				<p>Return values should never be boxed<br>

			<p><h4>vector literals</h4>
			A vector can be specified in-line as an argument
				<code>#{:vector "packageQualifiedTypeName"|tref|:int(etc) value ...}</code><br>

			<p><h4>References</h4>

				Reference types are returned with the following tagged syntax:<br>

				<code>#{:ref :id an-int :type a-ref :hash an-int :val marshalled-value}</code>
				<ul>


				<li>:ref must be first, and at least one of :id or :val must be supplied, all others are optional</li>

				<li>:id A unique integer reference that identifies the object. The object will be kept alive on the hosting side 
					until it is freed. Multiple references to the same object will always have the same id. 
					This will only be available if the marshall-id flag is set or when marshall-value-depth-limit is or reaches 0</li>

				<li>:type A reference to the Type (CLI) or Class (Java) object that is the type of the object. Note that this may be the 
					first time this reference is seen (and thus it must be registered for lifetime maintenance)
					This will only be available if the marshall-type flag is set.</li>

				<li>:hash An integer representing the hash value of the object. This will only be available if the marshall-hash flag is set.</li>

				<li>:val A Lisp-readable representation of the value of the object. This will be obtained by using the marshaller 
					registered for the type of the object. This will only be available when marshall-value-depth-limit is > 0. 
					Note #{ and #} user-space read macros are used by the implementation of foil.</li>
	

				</ul>
				 Note that it is possible to return marshalled values of reference objects without maintaining the reference object 
				 on the hosting side (by clearing the marshall-id flag and having marshall-value-depth-limit > 0

				 <p>A reference (obtained previously) is passed back to its host like this:

				 <p><code>#}an-int-id</code>

				 <p>The host will look up the object with that id and pass it along to the call.

		<br><h4>Exception Reporting</h4>
			All exceptions are reported via a return of the form:<p>
			<code>(:err "error description" "stack trace")</code><p>
				if an exception occurred while processing the request. Unless the exception originated in the reflection API, 
				it is preferred that the stack trace be of the inner (reflection-invoked) call.

<h3>Object support services</h3>
		<h4>Object references</h4>
		<h4>Object lifetime management</h4>
			<code>(:free refid ...)</code> -> nil
			

			<p>Allows one or more refs to be GC-ed on the hosting side. It is an error to refer to these refids again.<br>

        <h4>Object marshalling</h4><p>
			It is anticipated that runtime servers will provide for user-installable marshallers, associted with types,
			that will render the value of an object of that type on a stream in a form readable by Lisp. By default at least
			the following marshallers should be provided:
				<ul>

				<li>Type|Class - should marshall the string representing the packageQualifiedTypeName</li>
				<li>arrays - should marshall as simple vector literals: #(...)</li>
				<li>default, if no other marshaller applies - should yield an assoc-list of property-name/value pairs</li>

				</ul><p>
			In addition to marshalling returns during calls, the value of an object reference can be explicitly marshalled:
			<p><code>(:marshall ref marshall-flags marshall-value-depth-limit)</code> -> Lisp-readable-value

		<p>Hash values<br>
			<code>(:hash ref)</code> -> int<br>

		<p>Object equality<br>
			<code>(:equals ref ref)</code> -> t|nil, per Object.Equals<br>

		<p>ToString<br>
			<code>(:str ref)</code> -> "string value"<br>

 <p><h3>Reflection Services</h3>


	Note, when trefs are returned by these reflection calls, the :val field of the reference is always (default) marshalled, 
	i.e. set to the packageQualifiedTypeName as a string.

	<p><h4>Obtaining a reference to a Type/Class object</h4>
	<code>(:tref "packageQualifiedTypeName")</code> -> tref<br>

	<p><h4>Object type</h4>
		<code>(:type-of ref)</code> -> tref<br>


	<p><code>(:is-a ref tref)</code> -> t|nil<br>

	<p><code>(:bases tref|"packageQualifiedTypeName")</code><br>
<pre>
-> (:ret ("packageQualifiedTypeName" ...))    ;most-derived to least-derived
</pre>


	<p><code>(:members tref|"packageQualifiedTypeName")</code><br>

	<code>
<pre>
-> (:ret ( (:ctors doc-string ...)
        (:methods ((:name string)
                   (:static bool)
                   (:doc doc-string)) ...)
        (:fields ((:name string)
                  (:static bool)
                  (:doc doc-string)) ...)
        (:properties ((:name string)
                      (:static bool)
                      (:get-doc doc-string)
                      (:set-doc doc-string)) ...)))</pre></code>

<h4>Proxies</h4>
<pre>
<code>(:proxy marshall-flags marshall-value-depth-limit interface-trefs ...)</code><br>
-> (:ret proxy-ref)
</pre>
<p>
		Creates a proxy object that implements the given interface(s). When any of the object's methods are called,
		sends a :proxy-call message of the form:<p>
		<code>(:proxy-call method-symbol proxy-ref args ...)</code>
		<p>where the proxy-ref is the same one originally returned from the :proxy message, and the
		args are marshalled with the flags and depth requested in the :proxy message. method-symbol has the form<p>
		<code>|package.name|::classname.methodname</code><p>note this means that the Lisp names are not independent, hmmm...

<h3>Vectors</h3>
	Creating an vector:<br>
	<ul>

	<li>(:vector tref|"packageQualifiedTypeName" length value ...)
		Creates an vector of the specified type with the specified length
		Initial values are optional and may be fewer than the length.
		-> aref</li>
	<li>(:vget aref marshall-flags marshall-value-depth-limit index)
		-> value</li>
	<li>(:vset aref index value)
		-> nil</li>
	<li>(:vlen aref)
		-> int</li>
	</ul>

</body>
</html>
